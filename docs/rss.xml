<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0"><channel><title>zzb的博客</title><link>https://Air-ban.github.io</link><description>骑骥一跃不能十步，驽马十驾亦能不舍</description><copyright>zzb的博客</copyright><docs>http://www.rssboard.org/rss-specification</docs><generator>python-feedgen</generator><image><url>https://img.picui.cn/free/2024/06/25/6679b2b326191.jpg</url><title>avatar</title><link>https://Air-ban.github.io</link></image><lastBuildDate>Tue, 09 Jul 2024 14:59:16 +0000</lastBuildDate><managingEditor>zzb的博客</managingEditor><ttl>60</ttl><webMaster>zzb的博客</webMaster><item><title>范进</title><link>https://Air-ban.github.io/post/fan-jin.html</link><description># 稳啦，全部都稳啦&#13;
下午三点半出分，稳啦，全部都稳啦！！！！！！！！！！！！！！！！！！！！！！！！&#13;
&#13;
跟上zzb的节奏，稳啦，都稳啦！&#13;
&#13;
## 包过的。</description><guid isPermaLink="true">https://Air-ban.github.io/post/fan-jin.html</guid><pubDate>Mon, 01 Jul 2024 04:17:48 +0000</pubDate></item><item><title>毕业快乐！</title><link>https://Air-ban.github.io/post/bi-ye-kuai-le-%EF%BC%81.html</link><description># 该来的，总是会来的&#13;
我的初中生涯将在明天画上句号，这也意味着往后的日子，我就不是初中生了，其实并没有什么实质的感觉，就好像是从一家公司，跳槽到了另一家公司，而且还需要承受更加苦难的工作，这一切都没什么&#13;
&#13;
## 名言名句&#13;
以下是初中阶段，能让我发笑的句子，他们大多数都是由老师说出来的，确实活跃了课堂氛围，同时也调动了学生的积极情绪&#13;
&gt;这个xxx有没有脑子啊！——班主任兼数学老师&#13;
&#13;
&gt;这题目对你们来说，都是小菜！ 我们才是真正的小菜 ——某同学与某老师的对话&#13;
&#13;
&gt;不带你们这么玩的奥，所有东西教过了，结果到你们这什么都不会 ——班主任兼数学老师&#13;
&#13;
&gt;我滴孩来！ ——班主任兼数学老师&#13;
&#13;
&gt;就你们这点水平，念什么书啊！ ——班主任兼数学老师&#13;
&#13;
当然还有更多的句子，我有的也记不起来了，肯定是数学老师留下的印象最深刻啦，也十分感激我的数学老师把我带进了数学的大门，是我遇到过的为数不多的好老师，虽然有时有点毒舌，但总归还是不错的&#13;
&#13;
# 毕业快乐！&#13;
![freecompress-1419C967EE943032451213E2C884F882.jpg](https://s2.loli.net/2024/06/30/vCaLA7jVB4RXD1u.jpg)。</description><guid isPermaLink="true">https://Air-ban.github.io/post/bi-ye-kuai-le-%EF%BC%81.html</guid><pubDate>Sat, 29 Jun 2024 16:15:52 +0000</pubDate></item><item><title>简谈哈希碰撞</title><link>https://Air-ban.github.io/post/jian-tan-ha-xi-peng-zhuang.html</link><description># 内容概览&#13;
本文简要介绍哈希碰撞以及其中的生日攻击数学模型&#13;
## 一、哈希碰撞是什么？&#13;
所谓哈希（hash），就是将不同的输入映射成独一无二的、固定长度的值（又称'哈希值'）。</description><guid isPermaLink="true">https://Air-ban.github.io/post/jian-tan-ha-xi-peng-zhuang.html</guid><pubDate>Fri, 28 Jun 2024 16:58:54 +0000</pubDate></item><item><title>关于4096位RSA加密在校园墙的运用</title><link>https://Air-ban.github.io/post/guan-yu-4096-wei-RSA-jia-mi-zai-xiao-yuan-qiang-de-yun-yong.html</link><description># 校园墙加密方式&#13;
本文会详细介绍该校园墙的加密方式，以及实现方式以及实现细节&#13;
## 技术细节&#13;
由于考虑到人数，这里使用RSA加密，并且是4096的RSA加密，可以极大提高用户数据安全性，以下是实现RSA4096的具体方式&#13;
&#13;
首先，需要获取私钥与密钥，这里使用一个生成器，借用python中```cryptography```库来进行所有有关RSA加解密的操作，以下是生成4096位私钥和公钥的源代码&#13;
```python&#13;
from cryptography.hazmat.primitives.asymmetric import rsa&#13;
from cryptography.hazmat.primitives import serialization&#13;
from cryptography.hazmat.backends import default_backend&#13;
&#13;
def generate_rsa_key_pair(key_size=4096):&#13;
    private_key = rsa.generate_private_key(&#13;
        public_exponent=65537,&#13;
        key_size=key_size,&#13;
        backend=default_backend()&#13;
    )&#13;
    public_key = private_key.public_key()&#13;
    return private_key, public_key&#13;
&#13;
def save_key(key, filename):&#13;
    with open(filename, 'wb') as f:&#13;
        f.write(key.private_bytes(&#13;
            encoding=serialization.Encoding.PEM,&#13;
            format=serialization.PrivateFormat.PKCS8,&#13;
            encryption_algorithm=serialization.NoEncryption()&#13;
        ))&#13;
&#13;
def save_public_key(key, filename):&#13;
    with open(filename, 'wb') as f:&#13;
        f.write(key.public_bytes(&#13;
            encoding=serialization.Encoding.PEM,&#13;
            format=serialization.PublicFormat.SubjectPublicKeyInfo&#13;
        ))&#13;
&#13;
# 生成RSA密钥对&#13;
private_key, public_key = generate_rsa_key_pair()&#13;
&#13;
# 保存私钥和公钥到文件&#13;
save_key(private_key, 'private_key.pem')&#13;
save_public_key(public_key, 'public_key.pem')&#13;
&#13;
print('RSA key pair generated and saved.')&#13;
```&#13;
上述代码均添加了注释，**简单易懂**，因为是使用系统随机数生成的密钥对，就算是按照这份程序重新生成，也无法得到一样的密钥&#13;
&#13;
在RSA中，公钥用于加密，私钥用于解密，所以，加密时使用公钥，解密时使用私钥，以下是加密代码&#13;
&#13;
```python&#13;
from cryptography.hazmat.primitives import serialization, hashes&#13;
from cryptography.hazmat.primitives.asymmetric import padding, rsa&#13;
from cryptography.hazmat.backends import default_backend&#13;
import os&#13;
&#13;
def load_public_key(key_path: str):&#13;
    with open(key_path, 'rb') as key_file:&#13;
        public_key = serialization.load_pem_public_key(&#13;
            key_file.read(),&#13;
            backend=default_backend()&#13;
        )&#13;
    return public_key&#13;
&#13;
def encrypt_file_rsa(public_key: rsa.RSAPublicKey, input_file_path: str, output_file_path: str):&#13;
    with open(input_file_path, 'rb') as f:&#13;
        data = f.read()&#13;
&#13;
    # 由于RSA加密的局限性，这里假设文件内容不会超过公钥的最大加密尺寸&#13;
    # 对于大文件，您应该使用对称加密来加密文件内容，然后只使用RSA加密对称密钥&#13;
    encrypted_data = public_key.encrypt(&#13;
        data,&#13;
        padding.OAEP(&#13;
            mgf=padding.MGF1(algorithm=hashes.SHA256()),&#13;
            algorithm=hashes.SHA256(),&#13;
            label=None&#13;
        )&#13;
    )&#13;
&#13;
    with open(output_file_path, 'wb') as f:&#13;
        f.write(encrypted_data)&#13;
&#13;
def main():&#13;
    # 加载公钥&#13;
    public_key_path = 'public_key.pem'&#13;
    public_key = load_public_key(public_key_path)&#13;
&#13;
    # 加密文件 格式可以是任意格式，并不局限于这两种格式&#13;
    input_file_path = '加密前文件.txt'&#13;
    output_file_path = '加密后文件.bin'&#13;
    encrypt_file_rsa(public_key, input_file_path, output_file_path)&#13;
&#13;
    print(f'File '{input_file_path}' has been encrypted to '{output_file_path}'')&#13;
&#13;
if __name__ == '__main__':&#13;
    main()&#13;
```&#13;
这一切看上去真的是十分的美妙且优雅，没话说，一切加密的运作及其合理，使用公钥进行文件加密，并且加密后直接删除源文件，密钥丢了就彻底寄了，所以不要考虑信息或文件泄露，你们的信息安全是我唯一保证的目标&#13;
&gt;你上次不是说要用PGP吗？为什么不用了？&#13;
&#13;
针对这个问题，相信会写代码的都会选择较为轻松且加密效果好的加密算法，像RSA这种非对称加密算法，就十分符合我们的需求，并且对于单一文件并不需要消耗过多的资源&#13;
&#13;
好的，说完了加密，我们要来说说解密，以下是使用RSA私钥进行解密的代码&#13;
```python&#13;
from cryptography.hazmat.primitives import serialization, hashes&#13;
from cryptography.hazmat.primitives.asymmetric import padding, rsa&#13;
from cryptography.hazmat.backends import default_backend&#13;
import os&#13;
&#13;
def load_private_key(key_path: str):&#13;
    with open(key_path, 'rb') as key_file:&#13;
        private_key = serialization.load_pem_private_key(&#13;
            key_file.read(),&#13;
            password=None,  # 如果私钥有密码，请在此处提供&#13;
            backend=default_backend()&#13;
        )&#13;
    return private_key&#13;
&#13;
def decrypt_file_rsa(private_key: rsa.RSAPrivateKey, input_file_path: str, output_file_path: str):&#13;
    with open(input_file_path, 'rb') as f:&#13;
        encrypted_data = f.read()&#13;
&#13;
    # 使用RSA私钥解密数据&#13;
    decrypted_data = private_key.decrypt(&#13;
        encrypted_data,&#13;
        padding.OAEP(&#13;
            mgf=padding.MGF1(algorithm=hashes.SHA256()),&#13;
            algorithm=hashes.SHA256(),&#13;
            label=None&#13;
        )&#13;
    )&#13;
&#13;
    with open(output_file_path, 'wb') as f:&#13;
        f.write(decrypted_data)&#13;
&#13;
def main():&#13;
    # 加载私钥&#13;
    private_key_path = 'private_key.pem'&#13;
    private_key = load_private_key(private_key_path)&#13;
&#13;
    # 解密文件&#13;
    input_file_path = '加密后文件.bin'&#13;
    output_file_path = '解密后文件.txt'&#13;
    decrypt_file_rsa(private_key, input_file_path, output_file_path)&#13;
&#13;
    print(f'File '{input_file_path}' has been decrypted to '{output_file_path}'')&#13;
&#13;
if __name__ == '__main__':&#13;
    main()&#13;
```&#13;
&#13;
这里也可以看到，RSA解密也是非常的好写且通俗易懂，这三个模块已经融合在了校园墙机器人中，并且会在内部进行互相调用，我是啥也不知道，所以请对你们的个人隐私放100个心&#13;
### RSA技术原理&#13;
下面将为各位彻底解释清楚什么是RSA加密，以及RSA加密的原理&#13;
#### 加密&#13;
RSA的加密过程可以使用一个通式来表达&#13;
&gt;密文＝明文EmodN密文＝明文EmodN&#13;
&#13;
也就是说RSA加密是对明文的E次方后除以N后求余数的过程。</description><guid isPermaLink="true">https://Air-ban.github.io/post/guan-yu-4096-wei-RSA-jia-mi-zai-xiao-yuan-qiang-de-yun-yong.html</guid><pubDate>Thu, 27 Jun 2024 03:21:55 +0000</pubDate></item><item><title>自动校园墙机器人开发记录——其之一</title><link>https://Air-ban.github.io/post/zi-dong-xiao-yuan-qiang-ji-qi-ren-kai-fa-ji-lu-%E2%80%94%E2%80%94-qi-zhi-yi.html</link><description># 前言&#13;
最近，发现各种奇怪的事件都发在校园墙上了，但是这些校园墙大多数都是个人运营，无法确保信息安全以及公平公正，这几天看到两个人在墙上撕逼，很明显墙主（运营校园墙账号的人）有明显的偏袒迹象，所以打算开发一个绝对公正且尽可能不会泄露隐私的校园墙机器人&#13;
## 开发历程&#13;
刚开始，我是很直接的面向Google编程，确实找到了合适的脚本，但是吧，总感觉差点意思，因为只可以发文字，而且代码似乎还有些过时，以下是修改好后可以直接用的代码，但是只可以用于**发送文字**&#13;
&#13;
```python&#13;
from selenium import webdriver&#13;
from selenium.webdriver.common.by import By&#13;
from selenium.webdriver.support.ui import WebDriverWait&#13;
from selenium.webdriver.support import expected_conditions as EC&#13;
import time&#13;
&#13;
# 1. 打开网站，窗口最大化&#13;
driver = webdriver.Chrome()&#13;
driver.get('https://i.qq.com/')&#13;
driver.maximize_window()&#13;
&#13;
# 点击登录&#13;
try:&#13;
    WebDriverWait(driver, 10).until(EC.frame_to_be_available_and_switch_to_it('login_frame'))&#13;
    WebDriverWait(driver, 10).until(EC.element_to_be_clickable((By.XPATH, '//*[@id='img_out_此处填写QQ号']'))).click()&#13;
    driver.switch_to.default_content()&#13;
except Exception as e:&#13;
    print(f'An error occurred while trying to log in: {e}')&#13;
    driver.quit()&#13;
&#13;
# 点击说说&#13;
try:&#13;
    WebDriverWait(driver, 10).until(EC.element_to_be_clickable((By.XPATH, '//*[@id='menuContainer']/div/ul/li[5]/a'))).click()&#13;
except Exception as e:&#13;
    print(f'An error occurred while trying to click on 'Shuoshuo': {e}')&#13;
    driver.quit()&#13;
&#13;
# 切换框架&#13;
try:&#13;
    element = WebDriverWait(driver, 10).until(EC.presence_of_element_located((By.CSS_SELECTOR, 'iframe.app_canvas_frame')))&#13;
    driver.switch_to.frame(element)&#13;
    WebDriverWait(driver, 10).until(EC.element_to_be_clickable((By.ID, '$1_substitutor_content'))).click()&#13;
    WebDriverWait(driver, 10).until(EC.presence_of_element_located((By.ID, '$1_content_content'))).send_keys('自动化测试')&#13;
    WebDriverWait(driver, 10).until(EC.element_to_be_clickable((By.LINK_TEXT, '发表'))).click()&#13;
except Exception as e:&#13;
    print(f'An error occurred while trying to post a status update: {e}')&#13;
    driver.quit()&#13;
&#13;
# 检查一下&#13;
# Add any necessary checks here, or simply wait for a certain amount of time to see the result&#13;
time.sleep(10)&#13;
&#13;
# Remember to close the driver after you're done&#13;
driver.quit()&#13;
```&#13;
但使用这个脚本，需要电脑上已经**登陆QQ**的前提下，而且需要确保网络畅通，有没有什么更好的办法呢？因为我需要发送**图片**，单纯的文字已经无法满足我啦，但QQ发送图片需要重定向到资源管理器中选择图片，难办，那就使用框架自动进行点击操作吧，简单写个python脚本，来获取鼠标的位置信息&#13;
```python&#13;
from pynput import mouse&#13;
&#13;
# 定义一个函数来处理鼠标点击事件&#13;
def on_click(x, y, button, pressed):&#13;
    if pressed:&#13;
        print(f'Mouse clicked at ({x}, {y}) with button {button}')&#13;
&#13;
# 创建鼠标监听器&#13;
with mouse.Listener(on_click=on_click) as listener:&#13;
    listener.join()&#13;
```&#13;
这个脚本会实时记录你鼠标当前点击的位置坐标，并返回到控制台，本来打算写个log记录的，但是后来来想想，直接复制粘贴也不是不行，于是乎，通过断点，进行图片上传操作，并且记录坐标，在上面的自动发送文字说说脚本中加入了自动发送图片的点击程序，至此，完整的程序如下&#13;
```python&#13;
from selenium import webdriver&#13;
from selenium.webdriver.common.by import By&#13;
from selenium.webdriver.support.ui import WebDriverWait&#13;
from selenium.webdriver.support import expected_conditions as EC&#13;
import pyautogui&#13;
import time&#13;
from datetime import datetime&#13;
&#13;
# 获取当前系统时间并格式化为字符串&#13;
current_time = datetime.now().strftime('%Y-%m-%d %H:%M:%S')&#13;
&#13;
qq_number = input('请输入您的QQ号：')&#13;
&#13;
driver = webdriver.Chrome()&#13;
driver.get('https://i.qq.com/')&#13;
driver.maximize_window()&#13;
&#13;
try:&#13;
    WebDriverWait(driver, 10).until(EC.frame_to_be_available_and_switch_to_it('login_frame'))&#13;
    qq_login_button_xpath = f'//*[@id='img_out_{qq_number}']'&#13;
    WebDriverWait(driver, 10).until(EC.element_to_be_clickable((By.XPATH, qq_login_button_xpath))).click()&#13;
    driver.switch_to.default_content()&#13;
except Exception as e:&#13;
    print(f'An error occurred while trying to log in: {e}')&#13;
    driver.quit()&#13;
&#13;
try:&#13;
    WebDriverWait(driver, 10).until(EC.element_to_be_clickable((By.XPATH, '//*[@id='menuContainer']/div/ul/li[5]/a'))).click()&#13;
except Exception as e:&#13;
    print(f'An error occurred while trying to click on 'Shuoshuo': {e}')&#13;
    driver.quit()&#13;
&#13;
try:&#13;
    element = WebDriverWait(driver, 10).until(EC.presence_of_element_located((By.CSS_SELECTOR, 'iframe.app_canvas_frame')))&#13;
    driver.switch_to.frame(element) #此句代码后进入编辑器&#13;
    time.sleep(2)&#13;
    pyautogui.click(1070, 597) #相册&#13;
    time.sleep(1)&#13;
    pyautogui.click(1066, 658) #本地&#13;
    time.sleep(2)&#13;
    pyautogui.click(902, 254)&#13;
    pyautogui.click(902, 254)&#13;
    time.sleep(1)&#13;
    pyautogui.click(893, 168)&#13;
    pyautogui.click(893, 168)&#13;
    time.sleep(2)&#13;
    pyautogui.click(225, 185)&#13;
    pyautogui.click(814, 501)&#13;
    time.sleep(2)&#13;
    WebDriverWait(driver, 10).until(EC.element_to_be_clickable((By.ID, '$1_substitutor_content'))).click()&#13;
    WebDriverWait(driver, 10).until(EC.presence_of_element_located((By.ID, '$1_content_content'))).send_keys(current_time + '更新')&#13;
    WebDriverWait(driver, 10).until(EC.element_to_be_clickable((By.LINK_TEXT, '发表'))).click()&#13;
except Exception as e:&#13;
    print(f'An error occurred while trying to post a status update: {e}')&#13;
    driver.quit()&#13;
&#13;
time.sleep(3)&#13;
driver.quit()&#13;
```&#13;
为了确保定时发送，还写了个定时程序，和主程序是分开的，因为再写进去，感觉过于混乱了，定时程序如下：&#13;
```python&#13;
import os&#13;
import time&#13;
# 指定时间&#13;
target_time = time.time() + 5  # 5秒后执行&#13;
&#13;
# 无限循环，等待到达指定时间&#13;
while True:&#13;
    current_time = time.time()&#13;
    if current_time &gt;= target_time:&#13;
        # 到达指定时间，执行任务&#13;
        print('到达指定时间，开始执行任务')&#13;
        os.startfile('release.exe')&#13;
        break&#13;
    else:&#13;
        # 等待到达指定时间&#13;
        time.sleep(1)&#13;
```&#13;
当然，感觉给这个东西最外面加个```while True```是个不错的选择，但是，我是**懒狗**，接下来，需要获得素材，并且做到定点上传，素材将以图片的形式直接放在我的电脑文件夹中，通过上文的鼠标模拟点击来实现，至此，差不多是完成了，接下来只需要架设到服务器上即可&#13;
### 一些小感想&#13;
本人对于各种校内外八卦并无多少兴趣，开发这个脚本也纯粹是一时兴起，我并不感觉这玩意有什么实质性价值，但是，开发出来确实是会给人以成就感，当然，我在3h内完成了这些的开发，并且在1h写完这篇blog&#13;
&#13;
现在校内的各种事件层出不穷，尤其是在一些规模较大的学校，但很明显，这些校外的校园墙或者论坛不是老师可以干涉的地方，老师们通常只擅长**教书育人**，对于信息技术并没有过多的了解，但希望有朝一日，学生们可以摆脱由于校外环境导致的情绪异常，不被无意义的言论攻击&#13;
&#13;
共勉&#13;
&#13;
## 挖坑&#13;
&gt;你不是说要保障私密吗？怎么保障？&#13;
&#13;
这里本人大致思想是使用PGP签名，让程序自己生成密钥，我不会获取密钥，让程序之间互相完成加解密，我作为开发者，服务器拥有者，无法查看具体内容，并且在完成对于指定投稿者的内容获取和加密后，自动删除原文，只保留加密后的副本，以减少信息泄露所带来的影响，不过那都是后话了，说不定会在一周内爆肝出来？我不知道，再说吧&#13;
。</description><guid isPermaLink="true">https://Air-ban.github.io/post/zi-dong-xiao-yuan-qiang-ji-qi-ren-kai-fa-ji-lu-%E2%80%94%E2%80%94-qi-zhi-yi.html</guid><pubDate>Wed, 26 Jun 2024 16:54:32 +0000</pubDate></item><item><title>安卓手机ROOT教程</title><link>https://Air-ban.github.io/post/an-zhuo-shou-ji-ROOT-jiao-cheng.html</link><description># 说在前面&#13;
&gt;没电脑的，请直接退出此教程，谢谢！在ROOT的操作过程中，85%的步骤都依靠电脑，没电脑是不行的，所以不要浪费自己的时间，谢谢！&#13;
## 什么是root&#13;
此处引用百科&#13;
&gt;手机ROOT通常是指针对Android系统的手机而言，它使得用户可以获取Android操作系统的超级用户权限。</description><guid isPermaLink="true">https://Air-ban.github.io/post/an-zhuo-shou-ji-ROOT-jiao-cheng.html</guid><pubDate>Tue, 25 Jun 2024 12:23:57 +0000</pubDate></item><item><title>被勒索经历</title><link>https://Air-ban.github.io/post/bei-le-suo-jing-li.html</link><description># 起因&#13;
某天晚上，我闲来无事，突然想要整理一下那极其混乱的邮件，就在整理的时候，看到了一个非常令我诧异的邮件，里面包含了我所有的*浏览器*保存的密码，还有一张我的屏幕截图，大致情况如图所示&#13;
![3f0c6ac2ef0c4d866802f6f81b1ccf05.png](https://s2.loli.net/2024/06/25/LDHJBITgcpXw7hU.png)&#13;
我就很诧异啊，什么情况，怎么泄露的？我想啊想，还是没想到，但是可以看到，下面他给出了details，那就让我们一起看看里面写了什么&#13;
## 离谱的details&#13;
***已使用Google进行机翻***&#13;
![755662f6fa4cb72a9f943dfafaa5028b.png](https://s2.loli.net/2024/06/25/49hCDuUiQLKJAcz.png)&#13;
&#13;
&#13;
好的，这一切让我更摸不着头脑了，里面一个很牛逼哄哄的人威胁我给他比特币钱包打款1050刀，不然拿我账号去乱搞，此时此刻，我突然回想到前几天，微软强制我重置密码，这么看来，他的东西应该是已经过期的了，此时此刻的我丝毫不慌，甚至写了篇邮件骂了回去，不过还是让我细思极恐，毕竟我平日里也是比较喜欢像这样监视他人的，但是我并没有什么坏心思，但这次，让我感觉，杀软是不装不行了，我之前电脑一直是**裸奔的状态**，直到这次，我重新把火绒下回来了&#13;
### 启示&#13;
其实也不能算作是启示吧，只能说是给我们一点小提醒，这堆密码泄露了，没什么，但真正重要的是密码的习惯，现在导致我不可以使用一些**比较好记的密码**了，岂可休，于是乎我换了一套新的密码体系，只不过这套新的密码体系还需要一段时间来适应&#13;
&#13;
这对于大部分人来说，应该是极小概率遇到的事件，但我就是那个幸运儿，虽然不知道干了什么好事，但总归不是什么好事，还是希望大家以后可以多多加强个人信息保护意识，减少此类事件的发生&#13;
&#13;
&#13;
。</description><guid isPermaLink="true">https://Air-ban.github.io/post/bei-le-suo-jing-li.html</guid><pubDate>Mon, 24 Jun 2024 17:42:50 +0000</pubDate></item></channel></rss>